#!/usr/bin/env python
from __future__ import print_function
import time
from redis import Redis
from dispatch import Dispatch, unpack_trigger_type, unpack_header, unpack_pmt_record, RECORD_IDS
from collections import defaultdict
import zmq
import threading
from minard.timeseries import INTERVALS, EXPIRE

redis = Redis()

# triggers, note: the order here is important!
# the position of the trigger in the list corresponds to the bit in the
# trigger word.
# http://snopl.us/docs/rat/user_manual/html/node43.html
TRIGGER_NAMES = \
['100L',
 '100M',
 '100H',
 '20',
 '20LB',
 'ESUML',
 'ESUMH',
 'OWLN',
 'OWLEL',
 'OWLEH',
 'PULGT',
 'PRESCL',
 'PED',
 'PONG',
 'SYNC',
 'EXTA',
 'EXT2',
 'EXT3',
 'EXT4',
 'EXT5',
 'EXT6',
 'EXT7',
 'EXT8',
 'SRAW',
 'NCD',
 'SOFGT',
 'MISS']

def post(host):
    """Posts the dispatcher name to redis every 20 seconds."""
    redis.setex('dispatcher',host,60)
    timer = threading.Timer(20.0, post, args=[host])
    timer.daemon = True
    timer.start()

def push(host):
    """
    Connects to a dispatcher at ip address `host` and pushes the records to
    a ZMQ socket.
    """
    dispatcher = Dispatch(host)

    post(host)

    context = zmq.Context()
    zmq_socket = context.socket(zmq.PUSH)
    zmq_socket.bind('tcp://127.0.0.1:5560')

    for record in dispatcher:
        zmq_socket.send(record)

def pull():
    """Connects to a ZMQ socket and processes the dispatch stream."""
    context = zmq.Context()
    zmq_socket = context.socket(zmq.PULL)
    zmq_socket.connect('tcp://127.0.0.1:5560')

    cache = defaultdict(int)
    cache_set = {}
    nhit_cache = []
    event_cache = defaultdict(int)

    then = int(time.time())

    while True:
        try:
            record = zmq_socket.recv(zmq.NOBLOCK)
        except zmq.ZMQError:
            record = None

        # unix timestamp
        now = int(time.time())

        if now > then:
            # for docs on redis pipeline see http://redis.io/topics/pipelining
            p = redis.pipeline(transaction=False)

            ts = then
            for key, value in cache.items():
                for interval in INTERVALS:
                    redis_key = 'ts:%i:%i:%s' % (interval, ts//interval, key)
                    p.incrby(redis_key,value)
                    p.expire(redis_key,interval*EXPIRE)

            for key, value in cache_set.items():
                for interval in INTERVALS:
                    redis_key = 'ts:%i:%i:%s' % (interval, ts//interval, key)
                    p.setex(redis_key,value,interval*EXPIRE)

            for key, value in event_cache.items():
                redis_key = 'ev:60:%i:pmt:%s' % (ts//60,key)
                p.incrby(redis_key,value)
                p.expire(redis_key,600)

            p.incrby('ev:60:%i:count' % (ts//60),cache['TOTAL'])
            p.expire('ev:60:%i:count' % (ts//60),600)

            if len(nhit_cache) > 0:
                # nhit distribution
                # see http://flask.pocoo.org/snippets/71/ for this design pattern
                p.lpush('ev:1:%i:nhit' % ts,*nhit_cache)
                p.expire('ev:1:%i:nhit' % ts,3600)

            for interval in INTERVALS:
                p.setex('ts:%i:%i:heartbeat' % (interval, ts//interval),1,interval*EXPIRE)

            cache.clear()
            cache_set.clear()
            nhit_cache = []
            event_cache.clear()
            then = now

            p.execute()
                
        if record is None:
            # nothing to process, take a break
            time.sleep(0.01)
            continue

        record_id, data = unpack_header(record)

        if record_id != RECORD_IDS['PMT_RECORD']:
            continue

        pmt_gen = unpack_pmt_record(data)

        pev = next(pmt_gen)

        run = pev.RunNumber
        gtid = pev.TriggerCardData.BcGT
        nhit = pev.NPmtHit
        subrun = pev.DaqStatus # seriously :)
        trig = unpack_trigger_type(pev)

        nhit_cache += [nhit]

        qhs_sum = 0
        for pmt in pmt_gen:
            id = 16*32*pmt.CrateID + 32*pmt.BoardID + pmt.ChannelID
            event_cache[id] += 1

            qhs_sum += pmt.Qhs

        cache['TOTAL'] += 1
        cache['TOTAL-nhit'] += nhit
        cache['TOTAL-charge'] += qhs_sum
        cache_set['run'] = run
        cache_set['subrun'] = subrun
        cache_set['gtid'] = gtid

        for i, name in enumerate(TRIGGER_NAMES):
            if trig & (1 << i):
                cache[name] += 1
                cache[name + '-nhit'] += nhit
                cache[name + '-charge'] += qhs_sum

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Process SNO+ events from a dispatch stream')
    parser.add_argument('action', help='push/pull')
    parser.add_argument('--host', default='builder1.sp.snolab.ca', help='hostname of the dispatcher')
    args = parser.parse_args()

    if args.action == 'push':
        push(args.host)
    else:
        pull()
